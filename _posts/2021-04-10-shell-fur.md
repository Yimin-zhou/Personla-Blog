---
date: 2021-04-10 23:48:05
layout: post
title: Fur shader
subtitle: 单PASS的shell模型毛发shader
description: >-
  Single PASS shell model hair shader
image: https://s6.jpg.cm/2022/08/03/PQ24Ui.gif
tags: [project]
---

## Goal
Implement hair effect with shell under single pass.
Adjustable information about number of layers, length, etc.
Vertex motion to make the hairs match the object motion.

## Idea
### 1. Understand the shell model: Roughly, a single hair is composed of multiple layers of structure, which looks like a hair when there are enough layers and close together. The hairs grow in the normal direction, and the alpha value (replaced by a noise map) is used to decrement the size of each layer.
![](/assets/img/shell_fur/1.png)

### 2. Single-layer Shell implementation. 
Step 1: First implement an eye normal direction for vertex extents.
```
output.positionHCS = TransformObjectToHClip(float4(input.positionOS + input.normalOS * _SingleShellLen * layerNum ,1));
```

Step 2: Adjust the alpha value according to the different shell levels, the further out you go the finer it should be.
```
col.a = saturate(noise - _LayerNum); 
col.a *= noise;
```
First the noise map is sampled as an alpha. 
Then the alpha is decremented according to the number of layers to make the tip hairs look finer. But since we haven't implemented the multi-layer shell yet, we can't see the actual effect yet. The LayerNum here represents the offset of the current layer, which will be passed in through the script. Finally, multiply the noise map (multiply the hair ends so that they are not connected).
Do not turn off depth writing, then use OneMinusSrcAlpha blending mode.

### 3. Multi-layer shell implementation. 
This is the most important step. A multi-layer shell can directly represent the hairs, but since the effect has to be achieved in a single pass, a script is used to do it. 
Step 1: A simple setup for the shader will allow you to see the option to turn on gpu instancing in the material panel, but it is not enough yet. The reason for using GPU instancing is to avoid too much overhead when the script is turned on later.
![](/assets/img/shell_fur/2.png)
```
#pragma multi_compile_instancing
```

The current general idea is to use a script to generate multiple objects and then pass in different _LayerNum parameters for different objects to achieve a multi-layer shell implementation. (and turn the generated objects into sub-objects of the initial object)
 Step 2: Turn the model into a prefab, and use shellLevel to control the number of layers. Generate object (prefab) with the same number of layers-1.
 ```
public Transform prefab; 
public int shellLevel = 10; 
void Start() 
{ for (int i = 0; i < shellLevel; i++) 
{ Transform level = Instantiate(prefab); 
level.localPosition = transform.position;
 level.SetParent(transform); } 
 MaterialPropertyBlock propertyBlock = new MaterialPropertyBlock();
  propertyBlock.SetFloat("_LayerNum", 0.1f * i * 0.02f); 
  GetComponent().SetPropertyBlock(propertyBlock);
```

Meanwhile, each newly generated object is passed a different LayerNum parameter, and here we start with a simple increment based on the i value. An exaggerated approximate effect is as follows.
![](/assets/img/shell_fur/3.png)

Step 3: Refine the gpu instancing in the shader. 
Use unity's macros to store the parameters that need to be changed into a buffer first.
```
UNITY_INSTANCING_BUFFER_START(InstanceProperties) 
UNITY_DEFINE_INSTANCED_PROP(float, _LayerNum) 
UNITY_INSTANCING_BUFFER_END(InstanceProperties)
```
And use the _LayerNum property with the following macro in the code afterwards.
```
UNITY_ACCESS_INSTANCED_PROP(InstanceProperties,_LayerNum)
```
Do the same with the previous SingleShellLen parameter to facilitate control together in the script. Adjust the script so that it can modify various parameters in real time (which is not perfect yet).
![](/assets/img/shell_fur/4.png)
Step 4: Refine the basic effect of the hair in the shader.
```
col.a = (noise*2-(step *step + step*5)) * _FurDensity; 
col.a *= noise;
```
Before multiplying the noise map in the last step make a fitting function with a new parameter to control the density of the hairs. Also put in the script and modify it together [3].

Step 4: Refine the script. The previous script had some problems with real time changes (increasing and decreasing the number of layers at the same time would cause a wrong rendering order), so it was changed to require keystrokes for generation. Using the custom editor, two buttons were added to the script, one to clear the original hair and one to generate a new hair.
![](/assets/img/shell_fur/5.png)

### 4. Lights. 
Once the basic effect of the hair is achieved, it is time to match the hair with a suitable lighting effect. Roughly divided into 2 parts: ambient light, sss effect.
The first step: the SSS effect. In the back with a similar Fresnel to produce a simple sss effect.
```
float3 backLightDir = N * _BackSSDistortion + L; 
float backSSS = max(0,min(1,1-dot(V,backLightDir))); 
float3 sssResult = saturate(backSSS * _SSSIntensity);
```
![](/assets/img/shell_fur/6.png)

Step 2: Ambient light. Ambient light uses SH. 
![](/assets/img/shell_fur/7.png)
![](/assets/img/shell_fur/8.png)

Step 3: Ambient light masking and shadows. Set a shadow color and then linear difference with layerOffset to make the hair roots darker and add parameter settings [3]. Also shading the ambient light. For all lighting results ah multiply dot(N,L)
```
baseColor.rgb = lerp(_ShdowColor.rgb * baseColor.rgb,baseColor.rgb,layerOffset * _ShadowRange);
....

float3 ambient_SH = SampleSH(float4(N, 1));
half Occlusion =pow(layerOffset,2.2); 
Occlusion +=0.04 ;
half3 SH_result = lerp (shadowColor*ambient_SH,ambient_SH,Occlusion * shadowRange) ;
```
![](/assets/img/shell_fur/9.png)

### 5. Hair movement. 
Step 1: Affected by gravity. The hairs are offset by a curve affected by layerOffset, the more the tip is affected by gravity.
```
float3 GetGravity(float layerOffset) { 
return pow(layerOffset,3) * mul(unity_ObjectToWorld,_GravityDirection) * _GravityForce; 
}
```
![](/assets/img/shell_fur/10.png)

Step 2: Realize that the object displacement hair also follows the displacement. Assert a parameter _MovementOffset in the shader, and then update this parameter in real time in the script. The general principle is that when the object is in motion, the vertex at the tip of the offset (pow(layerOffset,3) can be achieved [3]) is offset in the opposite direction of the motion to achieve a hair movement effect.
```
float3 GetMovement(float layerOffset) { r
eturn pow(layerOffset,3) * mul(unity_ObjectToWorld,_MovementOffset); 
}
```

Now the code used to implement the gravity effect in the shader is modified to change the fixed gravity direction to _MovementOffset, which is passed from the footer. 
In the script, you need to get the direction of motion of the current object, then determine the _MovementOffset based on the direction of motion and pass it to the material in real time. 
Add a rigid body to the parent object to get the direction of motion from the rigid body. (There is a simple motion code in the script, for demonstration purposes)
parentRb.velocity = new Vector3(0.5f * Mathf.Sin(Time.time * 0.5f * Mathf.PI), 0.5f * Mathf.Sin(Time.time * 0.5f * Mathf.PI), 0); 
furOffset = parentRb.velocity;

Then add the option to flip the xyz axis in the script (for adjusting the direction of the fur when it is in motion)
![](/assets/img/shell_fur/11.png)

### 6. Refinement: Add lighting related parameters from materials to the script, and change all parameters except the shell layer parameter to be updated in real time in the script. Screenshot of the script.
![](/assets/img/shell_fur/7.png)
You can see that most of the parameters are adjusted using this script.
 The material only needs to have the relevant maps: !
![](/assets/img/shell_fur/12.png)
![](/assets/img/shell_fur/13.png)

### 7. Summary 
If the number of layers of hairs is updated in real time in the script (deleting and generating new sub-objects in real time), it will cause some errors in the rendering order, which is solved by the modification of the non-real time limit on the number of layers of hairs.


---